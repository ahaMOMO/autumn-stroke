# IOS下clIck事件延迟300ms原理解析

### 1.原因

**由于区分单击事件和双击屏幕缩放的原因造成的**

2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。

双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。

原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。

### 2.浏览器开发商的解决方案

##### 2.1  禁止缩放

当HTML文档头部包含如下`meta`标签时：

```html
<meta name="viewport" content="user-scalable=no">
<meta name="viewport" content="initial-scale=1,maximum-scale=1">
```

表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟。

缺点：

就是必须通过**完全禁用缩放来达到去掉点击延迟的目的**，然而完全禁用缩放并不是我们的初衷，我们只是想禁掉默认的双击缩放行为，这样就不用等待300ms来判断当前操作是否是双击。但是通常情况下，我们还是希望页面能通过双指缩放来进行缩放操作，比如放大一张图片，放大一段很小的文字。

##### 2.2  更改默认的视口宽度

一开始，为了让桌面站点能在移动端浏览器正常显示，移动端浏览器默认的视口宽度并不等于设备浏览器视窗宽度，而是要比设备浏览器视窗宽度大，通常是980px。我们可以通过以下标签来设置视口宽度为理想宽度。

```js
<meta name="viewport" content="width=device-width">
```

因为双击缩放主要是用来改善桌面站点在移动端浏览体验的，而随着响应式设计的普及，很多站点都已经对移动端坐过适配和优化了，这个时候就不需要双击缩放了，如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述`meta`标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。

这个方案相比方案一的好处在于，它没有完全禁用缩放，而**只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。**

##### 2.3  CSS touch-action

`touch-action`这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。如果将该属性值设置为`touch-action: none`，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。

### 3.现有的解决方案

##### 3.1 指针事件的polyfill

现在除了IE，其他大部分浏览器都还不支持指针事件。有一些JS库，可以让我们提前使用指针事件，比如

- Google 的 [Polymer](https://link.jianshu.com?t=https://github.com/Polymer/PointerEvents)
- 微软的 [HandJS](https://link.jianshu.com?t=http://handjs.codeplex.com/)
- [@Rich-Harris](https://link.jianshu.com?t=https://github.com/Rich-Harris) 的 [Points](https://link.jianshu.com?t=https://github.com/Rich-Harris/Points)

然而，我们现在关心的不是指针事件，而是与300ms延迟相关的CSS属性`touch-action`。由于除了IE之外的大部分浏览器都不支持这个新的CSS属性，所以这些指针事件的polyfill必须通过某种方式去模拟支持这个属性。一种方案是JS去请求解析所有的样式表，另一种方案是将`touch-action`作为html标签的属性。

##### 3.2 FastClick

[FastClick](https://link.jianshu.com?t=https://github.com/ftlabs/fastclick) 是 [FT Labs](https://link.jianshu.com?t=http://labs.ft.com/) 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。

### 4.FasstClick原理

首先了解一下移动端触摸响应事件的顺序为：touchstart->touchmove->touchend->mousemove->mousedown->mouseup->click。

| 事件       | 描述       | **触发时机**           |
| ---------- | ---------- | ---------------------- |
| touchstart | 开始触摸   | 手指接触屏幕时立即触发 |
| touchmove  | 移动或拖拽 | 取决于系统和浏览器     |
| touchend   | 触摸结束   | 手指离开屏幕时立即出发 |

fastclick在touched阶段调用event.preventDefault阻止浏览器默认行为（这里的默认行为为原来的click事件），然后通过document.dispatchEvent创建一个mouseEvents,然后通过eventTarget.dispatchEvent触发对应目标元素上绑定的click事件。（简单来说就是在检测到tochend事件时，阻止原来的click事件，然后通过自定义dom事件立即发出模拟一个click事件去实现）。

但是，touched阶段之后不能每次都触发事件，因为有可能用户在上下滑动，而不是点击。

所以fastclick使用时间偏差去判断。它分别记录touchstart和touched的时间戳，如果它们的时间差大于700ms，则认为是滑动操作，否则是点击操作。

### 5.点击穿透

说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？
 使用touchstart去代替click事件有两个不好的地方。

 第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果；
 第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。

##### 5.1什么是点击穿透？

假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。

这是因为在移动端浏览器，事件执行的顺序是touchstart > touchend > click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。

##### 5.2点击穿透的几种形式

（1）点击穿透问题

点击蒙层（mask）上的关闭按钮，蒙层消失后发现触发了按钮下面元素的click事件,

蒙层的关闭按钮绑定的是touch事件，而按钮下面元素绑定的是click事件，touch事件触发之后，蒙层消失		了，300ms后这个点的click事件fire，event的target自然就是按钮下面的元素，因为按钮跟蒙层一起消失了。

（2）跨页面点击穿透问题

如果按钮下面恰好是一个有href属性的a标签，那么页面就会发生跳转。因为a标签跳转默认是click事件触发，所以原理和上面的完全相同。

（3）另一种跨页面点击穿透问题

这次没有mask了，直接点击页内按钮跳转至新页，然后发现新页面中对应位置元素的click事件被触发了。

和蒙层的道理一样，js控制页面跳转的逻辑如果是绑定在touch事件上的，而且新页面中对应位置的元素绑定的是click事件，而且页面在300ms内完成了跳转，三个条件同时满足，就出现这种情况了。

非要细分的话还有第四种，不过概率很低，就是新页面中对应位置元素恰好是a标签，然后就发生连续跳转了。。。诸如此类的，都是点击穿透问题。

##### 5.3解决方案

（1）只用touch

把页面内所有click全部换成touch事件（'touchstart'、’touchend’、’tap’）。

需要特别注意：a标签，a标签的href也是click，需要去掉换成js控制的跳转，或者直接改成span + tap控制跳转。如果要求不高，不在乎滑走或者滑进来触发事件的话，span + touchend就可以了，毕竟tap需要引入第三方库。

不用a标签其实没什么，移动app开发不用考虑SEO，即便用了a标签，一般也会去掉所有默认样式，不如直接用span。

（2）只用click

下下策，因为会带来300ms延迟，页面内任何一个自定义交互都将增加300毫秒延迟，想想都慢。不用touch就不会存在touch之后300ms触发click的问题，如果交互性要求不高可以这么做，强烈不推荐，快一点总是好的。

（3）click后延迟350ms再隐藏mask

改动最小，缺点是隐藏mask变慢了，350ms还是能感觉到慢的。只需要针对mask做处理就行，改动非常小，如果要求不高的话，用这个比较省力。

（4）pointer-events

比较麻烦且有缺陷，不建议使用。

mask隐藏后，给按钮下面元素添上`pointer-events: none;`样式，让click穿过去，350ms后去掉这个样式，恢复响应。缺陷是mask消失后的的350ms内，用户可以看到按钮下面的元素点着没反应，如果用户手速很快的话一定会发现。

（5）使用fastclick

好用的方案。





