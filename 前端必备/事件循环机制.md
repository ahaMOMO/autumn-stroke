### 1.基本概念

#### JS单线程

JS主要用途为与用户互动以及操作DOM，这决定了它只能是单线程。（假定JS同时有两个线程，一个为DOM添加内容，一个删除这个DOM，那么浏览器以谁为准呢？）

#### 同步任务

在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。存放位置为调用栈

#### 异步任务

不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，某个任务可以执行了，该任务才会进入主线程执行

#### 任务队列

除了IO设备事件之外，还包括一些用户产生的事件（鼠标点击、页面滚动等）。只要指定过回调函数，这些事件发生时都会进入“任务队列”。除了放异步任务，还可以放定时器。

- 宏任务(macro -task)

  > 参与事件循环的异步任务
  >
  > 主要有：script(主程序代码)、setTimeout、setInterval、setImmediate、 I/O、UI rendering

- 微任务(micro -task)

  > 为了解决一些高实时的任务（具有高优先级的异步任务）
  >
  > 主要有：process.nextTick、promises、async/await(await后的代码，await前和await里都为同步)、Object.observe、MutationObserver
  >
  > new promise实例化过程中的代码是同步的，then之后执行的才是微任务，微任务会在宏任务之前执行。
  >
  > await 是基于promise封装的，所以await之前的是同步代码，之后的是异步

宏任务的一些特殊任务执行顺序：

- timers阶段

  此阶段包括setTimeout()和setInterval()

- IO callbacks

  大部分的回调事件，普通的caollback

- poll阶段

  网络连接，数据获取，读取文件等操作

- check阶段

  setImmediate()在这里调用回调

- close阶段

   一些关闭回调，例如socket.on('close', ...)

微任务的一些特殊任务执行顺序：

开发过程中如果想让异步任务尽可能快地执行，可以使用 process.nextTick 来完成。所以执行完所有同步任务，接下来就会首先执行 process.nextTick 的任务队列。

#### setTimeOut(), setInterval(), setImmediate() 以及 process.nextTik()区别

setTimeout采用的是类似IO观察者，setImmediate采用的是check观察者，而process.nextTick()采用的是idle观察者。

**三种观察者的优先级顺序是：idle观察者>>io观察者>check观察者**



#### Event Loop(事件循环)

浏览器的事件循环的由来是因为js本身为单线程。所以在进行一些异步任务的时候为了不让主线程等待异步任务结果，所以出现了任务队列。任务队列放的是异步任务的回调函数。但是对于一些高时性的异步任务我们应该立即执行，而不是让它它参与事件循环，所以任务队列中的任务又分为微任务和宏任务。微任务中存放高时性的异步任务。

事件循环的流程为：主线程先执行完在主线程中的同步任务，执行完成之后进行任务队列执行异步任务。主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。



