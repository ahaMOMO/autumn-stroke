# 网络攻击

### 一、XSS攻击

#### 1.定义

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。

#### 2.分类

##### （1）存储型

存储型XSS的攻击脚本常常是由前端提交的数据未经过处理直接存储到数据库，然后从数据库中读取出来后又直接插入到页面中所导致的。

###### 攻击步骤：

- 攻击者将恶意代码提交到目标网站的数据库中。
- 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
- 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

###### 攻击例子：

```html
<!-- 是我们要渲染的内容模板 -->
<div>{{ content }}</div>

<!-- 从后台从数据库中读取数据返回并在前端页面模板中直接渲染导致存储型XSs，下面是渲染后输出的内容 -->
<div><script>alert();</script></div>
```

###### 常见攻击：

常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

##### （2）反射型

反射性XSS可能是在网页URL参数中注入了可解析内容的数据而导致的，如果直接获取URL中不合法的数据并插入页面中则可能出现出现页面上的XSS攻击。

###### 攻击步骤：

- 攻击者构造出特殊的 URL，其中包含恶意代码。
- 用户打开含有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
- 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

###### 攻击例子：

```html
<!-- 反射型xss，例如Node服务器端渲染数据，Web服务器脚本从前端URL中获取数据后直接渲染到前端页面导致 -->
let name = reg.query['name'];
this.body = '<div>$ {name}</div>';
<!-- url里传递的name参数值如果为'<script>alert();</script>', 则输出为<div><script>alert(); 会导致页面上的XSS -->
<!-- 例如http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script> -->
```

###### 常见攻击：

常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

> 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

##### （3）DOM型（MXSS）

MXSS则是在渲染DOM属性时将攻击脚本插入DOM属性中被解析而导致的。

###### 攻击步骤：

- 攻击者构造出特殊的 URL，其中包含恶意代码。
- 用户打开带有恶意代码的 URL。
- 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

###### 攻击例子：

```html
<!-- MXSs，页面标签元素属性在前端渲染时含有可解析的标签导致，下面是要渲染的内容 -->
<p calss="class-a {b1}"></p>
<!-- 插入悲意脚本内容的输出结果 -->
<p calss-"class-a "><script>alert()</script><p class="class-b"></p>
```

> DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

#### 3.如何阻止XSS攻击

##### （1）由服务器对输入脚本进行过滤或者转码

对一些明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤。

例如：

```
1235<script>alert('你被 xss 攻击了')</script>
```

这段代码过滤后，只留下了：1235；这样，当用户再次请求该页面时，由于`<script>`标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。

除了过滤外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：

```js
1235:&lt;script&gt;alert(&#39; 你被 xss 攻击了 &#39;)&lt;/script&gt;
```

但是对于其他不太明确的内容尽量不要使用这种方法。例如：一个正常的用户输入了 `5 < 7` 这个内容，在写入数据库前，被转义成了 `5 &lt 7`。现在问题是：如果前端从数据库读出这个内容，不知道要不要对符号进行还原，就有可能变成了乱码（5 &lt 7）,会引入很大的不确定性和乱码问题。

> 为什么不在前端对输入脚本进行过滤？
>
> 因为一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。

##### （2）充分利用CSP（网页安全策略）

虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。

###### CSP定义

CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。

它是一种由开发者定义的安全策略性声明，通过CSP所约束的规则设定，浏览器只可以加载指定可信的域名来源的内容（这里的内容可以是脚本、图片、iframe、font、style等远程资源）。通过CSP协定，Web只能加载指定安全域名下的资源文件，保证运行时的内容总处于一个安全的环境中。

###### 如何启用CSP

- 第一种可通过 HTTP 头信息的`Content-Security-Policy`的字段

  ```http
  Content-Security-Policy: script-src 'self'; object-src 'none';
  style-src cdn.example.org third-party.org; child-src https:
  ```

- 另一种是通过网页的`<meta>`标签。

  ```markup
  <meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:">
  ```

上面代码中，CSP 做了如下配置：

- 脚本：只信任当前域名
- `<object>`标签：不信任任何URL，即不加载任何资源
- 样式表：只信任`cdn.example.org`和`third-party.org`
- 框架（frame）：必须使用HTTPS协议加载
- 其他资源：没有限制

启用后，不符合 CSP 的外部资源就会被阻止加载。

###### CSP功能

- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
- 禁止向第三方域提交数据，这样用户数据也不会外泄；
- 禁止执行内联脚本和未授权的脚本；
- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。

> 具体CSP介绍可参考文章：http://www.ruanyifeng.com/blog/2016/09/csp.html

##### （3）使用HttpOnly属性

由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。

通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。

### 二、CSRF攻击

#### 1.定义

CSRF是指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。非源站点在取到用户登录验证信息的情况下，可以直接对源站点的某个数据接口进行提交，如果源站点对该提交请求的数据来源未经验证，该请求可能被成功执行，这其实并不合理。简单来讲，**CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些非法的事情。**通常比较安全的是通过页面Token (令牌)提交验证的方式来验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。

#### 2.原理

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720095928.jpg)

从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：

- 登录受信任网站A，并在本地生成Cookie。
- 在不登出A的情况下，访问危险网站B。

看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：

- 你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。
- 你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了......）
- 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。

#### 3.三种攻击方式

通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。

下面我们以极客时间官网为例子，来分析这三种攻击方式都是怎么实施的。这里假设极客时间具有转账功能，可以通过 POST 或 Get 来实现转账，转账接口如下所示：

```js
# 同时支持post/get
# 接口
https://time.geekbang.org/sendcoin
# 参数
## 目标用户
user
## 目标金额
number
```

##### （1）自动发起 GET 请求

黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：

```html
<!DOCTYPE html>
<html>
	<body>
        <h1>黑客的站点：CSRF攻击演示</h1>
        <img src="https://time.geekbang.org/sendcoin?user=hacker&number=100"/>
    </body>    
</html>
```

这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去了。

> 原因是该网站违反了HTTP规范，使用GET请求更新资源。再比如另外一个例子：黑客利用这个漏洞先在论坛中发表一个“<img src="https://time.geekbang.org/sendcoin?user=hacker&number=10"/>”评论，当用户进入这个论坛的时候，页面自动加载黑客的这个评论，因为这个评论是一个get请求，所以用户的浏览器就会带上自己的ccokie向服务器发送这个请求。服务器会认为这个请求是用户发出的（携带了用户cookie），所以造成了攻击。

##### （2）自动发起POST请求

除了自动发送 Get 请求之外，有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：

```html
<!DOCTYPE html>
<html>
	<body>
        <h1>黑客的站点：CSRF攻击演示</h1>
        <form id="hacker-form" action="https://time.geekbang.org/sendcoin" method="POST">
          	<input type="hidden" name="user" value="hacker" />
            <input type="hidden" name="number" value="100" /> 
        </form>
        <srcipt>document.getElementsById('hacker-form').submit();</srcipt>
    </body>    
</html>
```

在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。

##### （3）引诱用户点击链接

除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：

```html
<div>
    <img width=150 src="https://images.xuejuzi.cn/1612/1_24234534.jpg"/>
    <a href="https://time.geekbang.org/sendcoin?user=hacker&number=100" target="">
    	点击下载美女的图片
    </a>
</div>
```

这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。

以上三种就是黑客经常采用的攻击方式。如果当用户登录了极客时间，以上三种 CSRF 攻击方式中的任何一种发生时，那么服务器都会将一定金额的极客币发送到黑客账户。

> 和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。

#### 4.如何防范CSRF攻击

先总结一下CSRF攻击的三个必要条件：

- 第一个，目标站点一定要有 CSRF 漏洞；
- 第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；
- 第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。

满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。

防范手段如下：

##### （1）充分利用好Cookie中的SameSite属性

因为多数黑客会利用用户的登录状态来发起 CSRF 攻击，而**Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据**，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。

通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现**从第三方站点发送请求时禁止 Cookie 的发送**，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：

- 如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；
- 如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。

而我们要聊的 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。

那 SameSite 是怎么防止 CSRF 攻击的呢？在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：

```html
Set-Cookie: CookieName=CookieValue; SameSite=Strict;
```

SameSite 选项通常有 Strict、Lax 和 None 三个值。

![image-20200720125443292](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720125445.png)

> 对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。

##### （2）验证请求的来源站点

接着我们再来了解另外一种防止 CSRF 攻击的策略，那就是**在服务器端验证请求来源的站点**。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？

这就需要介绍 HTTP 请求头中的 Referer 和 Origin 属性了。

**Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址**。但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考**Referrer Policy**。

但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了**Origin 属性**，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，如下图：

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720130641.png)

>Referer：浏览器向Web服务器表明自己是从哪个网页URL跳转访问当前请求中网址URL的，即跳转到当前页面的来源。例如：Referer：https://time.geekbang.org/intro/216
>
>Origin：发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的响应投表示访问控制所允许的来源），例如：Origin：https://time.geekbang.org
>
>两者区别：Referer包含路径信息，Origin不包含路径信息
>
>在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。

##### （3）CSRF Token

除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token 来验证，这个流程比较好理解，大致分为两步。

当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可。

这里是大致过程：

- 客户端使用用户名跟密码请求登录
- 服务端收到请求，去验证用户名与密码
- 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
- 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者Local Storage 里
- 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
- 服务端收到请求，然后去验证客户端请求里面带着的 Token（request头部添加Authorization），如果验证成功，就向客户端返回请求的数据 ，如果不成功返回401错误码，鉴权失败。

### 三、请求劫持HTTPS

#### 1.DNS劫持

DNS劫持通常是指攻击者劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致用户对该域名地址的访问由原IP地址转入到修改后的指定IP地址的现象，其结果就是让正确的网址不能解析或被解析指向另一网站IP,实现获取用户资料或者破坏原有网站正常服务的目的。DNS劫持一般通过篡改DNS服务器上的域名解析记录，来返回给用户一个错误的DNS查询结果实现。

如图2-8所示，DNS劫持症状可能为在某些地区的用户在成功连接宽带网络后，访问域名为www.a.com的网站，出现的却是www.b.com网站的内容，因为DNS服务器www.a.com域名的解析结果被修改指向了www.b.com网站指向的IP地址。

![image-20200720161505415](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720161506.png)

#### 2.HTTP劫持

HTTP劫持是指，在用户浏览器与访问的目的服务器之间所建立的网络数据传输通道中从网关或防火墙层上监视特定数据信息，当满足一定的条件时，就会在正常的数据包中插入或修改成为攻击者设计的网络数据包，目的是让用户浏览器解释“错误”的数据，或者以弹出新窗口的形式在使用者浏览器界面上展示宣传性广告或者直接显示某块其他的内容。

如图2-9所示，这种情况下一般用户请求源网站的IP地址及网站加载的内容和脚本都是正确的，但是在网站内容请求返回的过程中，可能被ISP (Internet Service Provider，互联网服务提供商)劫持修改，最终在浏览器页面上添加显示一些广告等内容信息。

对于这些情况，网站开发者常常就无法通过修改网站代码程序等手段来进行防范了。请求劫持唯一可行的预防方法就是尽量使用HTTPS协议来访问目标网站。

![image-20200720161820897](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720161822.png)

#### 3.HTTPS

HTTPS协议是通过加入SSL（Secure Sockets Layer）层来加密HTTP数据进行安全传输的HTTP协议，同时启用默认的443端口及逆行数据传输。

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720162641.png)

从图中我们可以看出 HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。

总的来说，安全层有两个主要的职责：**对发起 HTTP 请求的数据进行加密操作**和**对接收到 HTTP 的内容进行解密操作**

我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。

##### （1）使用对称加密

提到加密，最简单的方式是使用对称加密。所谓**对称加密是指加密和解密都使用的是相同的密钥**

了解了对称加密，下面我们就使用对称加密来实现第一版的 HTTPS。

要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720162857.png)

通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：

- 浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的**加密套件是指加密的方法**，加密套件列表就是指浏览器能支持多少种加密方法列表。
- 服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。
- 最后浏览器和服务器分别返回确认消息。

这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。

通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着**黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥**，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。

##### （2）使用非对称加密

不过非对称加密能够解决这个问题，因此接下来我们就利用非对称加密来实现我们第二版的 HTTPS，不过在讨论具体的实现之前，我们先看看什么是非对称加密。

和对称加密只有一个密钥不同，**非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密**。

在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为**公钥**，服务器自己留下的那个密钥称为**私钥**。顾名思义，**公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开**。下图是使用非对称加密改造的 HTTPS 协议：

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720163723.png)

根据该图，我们来分析下使用非对称加密的请求流程。

- 首先浏览器还是发送加密套件列表给服务器。
- 然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。
- 最后就是浏览器和服务器返回确认消息。

这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。

但是，使用非对称加密也有缺陷：

- **第一个是非对称加密的效率太低**。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。
- **第二个是无法保证服务器发送给浏览器的数据安全**。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。

##### （3）对称加密和非对称加密搭配使用

基于以上两点原因，我们最终选择了一个更加完美的方案，那就是**在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输**。下图就是改造后的版本：

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720203234.png)

**从图中可以看出，改造后的流程是这样的：**

- 首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；
- 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；
- 浏览器保存公钥，并利用 client-random 和 service-random 计算出来 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；
- 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。

到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成**对称密钥**，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。

有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。

需要特别注意的一点，**pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了**。

##### （4）添加数字证书

通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。

所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？

对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。

接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720203716.png)

**相较于第三版的 HTTPS 协议，这里主要有两点改变：**

- 服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；
- 在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。

通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。

>**数字证书的申请与验证**
>
>我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：
>
>- 首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；
>- 然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；
>- CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；
>- 如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。
>
>这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用**Hash 函数**来计算极客时间提交的明文信息，并得出**信息摘要**；然后 CA 再使用它的私钥对信息摘要进行加密，**加密后的密文就是 CA 颁给极客时间的数字签名**。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。

>##### 浏览器如何验证数字证书
>
>有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。
>
>浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到**信息摘要 A**；然后再利用对应 CA 的公钥解密签名数据，得到**信息摘要 B**；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。
>
>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。
>
><u>另外，在申请和使用证书的过程中，还需要注意以下三点：</u>
>
>- 申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；
>- 数字证书最核心的是 CA 使用它的私钥生成的数字签名；
>- 内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。

#### 4.中间人攻击

针对SSL的中间人攻击方式主要有两类，分别是SSL劫持攻击和SSL剥离攻击。

##### （1）SSL劫持攻击

SSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据；

但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误，由用户选择继续操作还是返回，由于大多数用户的安全意识不强，会选择继续操作，此时，中间人就可以获取浏览器和服务器之间的通信数据。

##### （2）SSL剥离攻击

这种攻击方式也需要将攻击者设置为中间人，之后把HTTPS协议替换为HTTP返回给浏览器，而中间人和服务器之间仍然保持HTTPS服务器。由于HTTP是明文传输的，所以中间人可以获取客户端和服务器传输数据。

![image](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720205752.png)

但是我们可以通过设置Strict-Transport-Security(STS)预防。

> Strict Transport Security (STS)是一种用来配置浏览器和服务器之间安全通信的机制，主要用来防止中间者攻击，因为它强制所有的通信都使用HTTPS，在普通的HTTP报文请求中配置STS是没有作用的，而且攻击者也能更改这些值。为了防止这样的现象发生，很多浏览器内置了一个配置STS的站点列表,在Chrome浏览器下可以通过访问chrome://net-internals/#hsts查看浏览器中站点的STS列表，一般STS的配置实现如下。
>
> ```js
> //告诉浏览 器将域名缓存到sTS 列表中，只有这些特定域名下的资源内容才允许被加载，时间是一年
> max-age=31536000;
> //告诉浏览 器将域名缓存到sTS列表里面并且包含所有的子域名，并可支持预加载，时间是一年
> max-age=31536000;
> includeSubDomains;
> preload;
> //告诉浏览器移除在sTS缓存里的域名，或者不保存当前域名
> max-age=0
> ```

### 三、常见算法概念

#### 1.对称加密算法

对称加密算法的特点是加密密钥和解密密钥是同一把密钥K，且加解密速度快，典型的对称加密算法有DES、AES等。

![image](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720204733.png)

#### 2.非对称加密算法

非对称加密算法的特点是加密密钥K1和解密密钥K2是不一样的，他们是一对可互为加解密的密钥，一个可以公开，叫公钥；一个自己保留，不能让其他人知道，叫私钥。这样就能比较好的解决信息传递的安全性，相对来说加解密速度较慢，典型的非对称加密算法有RSA、DSA等。问题是如何保证加密用的接收者的公钥，即如何安全的传递公钥。

![image](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720204757.png)

#### 3.摘要算法、数字签名

F(M) = D       E(D)=S

F是单向散列函数:即如果已知x，很容易计算F(x)，但已知F(x)，却很难算出x

数字签名就是用私钥将摘要加密的结果，这样能够保证数据的完整性、放篡改、以及不可抵赖性。

![image](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720204929.png)

#### 4.校验数据的完整性

乙方把接收到的发送方的明文用单向哈希函数取得摘要值与甲方的公钥解密甲方的数字签名而得到的摘要值进行比较，如果一样说明信息完整，未受篡改，如果不一样说明受到篡改。

![image](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720205025.png)

#### 5.严密的数字加解密、数字签名与验证流程

在发送过程中首先将甲方的明文取摘要值，再将此摘要值用甲方的私钥加密得到甲方的签名，然后将甲的明文、数字签名和数字证书合在一起用甲方随机生成的对称密钥加密得到密文；第二步是将这一随机生成的对称密钥用乙方的公钥加密后得到数字信封；最后将密文和数字信封一起发送给乙方。

在乙方接收过程中，首先将收到数字信封用乙方的私钥解密，得到随机生成的对称密钥，第二步是解密得到的随机生成的对称密钥将密文解密，得到甲方的明文、数字签名和数字证书；第三步将甲方的明文取摘要值与甲方的数字签名用甲方的公钥解密得到的摘要进行比较，从而验证签名和检验数据的完整性。这一流程同时用到对称算法和非对称算法，是比较安全的流程

数字证书在这里起到的作用有：提供甲方的公钥，保证发送信息方的不可抵赖性。

![image](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200720205400.png)

### 四.常见面试题

#### 1.http和https的区别

（1.介绍http/https的概念->2.讲述两者区别->3.讲述https的工作原理->https的优缺点）

- http传输的数据都是未加密的，也就是明文的。https协议设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。
- 使用不同的链接方式，端口也不同.一般而言。http协议的端口为80，https的端口为443。
- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

#### 2.https的优缺点

优点：

- 有利于SEO

  比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高

- 更安全，是现有架构中最安全的解决方案

  使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

  HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

  HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

缺点：

- 使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电（因为SSL/TLS协议许需要一个握手过程）。
- HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。
- SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。
- SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
- SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
- HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。

#### 

参考文章：

https://tech.meituan.com/2018/09/27/fe-security.html

https://blog.poetries.top/browser-working-principle/

https://www.cnblogs.com/gordon0918/p/5237717.html