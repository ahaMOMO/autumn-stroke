# TCP与UDP

### 一.TCP

#### 1.首部组成结构

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200719112736.jpg)

- **源端口号**：标识主机上发起传送的应用程序

- **目的端口**：标识主机上传送要到达的应用程序

  > tcp中的源端口号和目的端口号加上IP首部中的源端IP地址和目的端IP地址能唯一确定一个TCP连接。

- **序号**（seq）：本报文段所发送的数据项目组第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为300，而且数据共100字节，则下一个报文段的序号就是400；序号是32bit的无符号数，序号到达2^32-1后从0开始。

- **确认号**（ack）：当对方收到这个确认号时，就能够确定之前的传递的数据包已经被正确的收下了，现在期望收到对方下次发送的数据的第一个字节的序号。确认序号应该是上次已成功收到数据字节序号+1。只有ACK标志为1时，确认序号才有效。

- 数据偏移：表示数据开始的地方离TCP段的起始处有多远，实际上就是TCP段首部的长度。由于首部长度不固定，因此数据偏移字段是必要的。

- 保留字段：供以后使用

- 状态控制码：标志位字段（U、A、P、R、S、F）占6比特

  - URG：当URG=1时，表示此报文应尽快传送，而不要按本来的列队次序来传送。与“紧急指针”字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长。
  - **ACK**：确认比特（Acknowledge）。只有当ACK＝1时确认号字段(ack)才有效。
  - PSH：当PSH=1时，接收方应该尽快将本报文段立即传送给其应用层，要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。
  - RST：复位比特(Reset) ,当RST＝1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
  - **SYN**：同步比特(Synchronous)，SYN置为1，就表示这是一个连接请求或连接接受报文,通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
  - **FIN**：终止比特(Final)，用来释放一个连接。当FIN＝1时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

- **窗口**：也叫滑动窗口，该字段用来控制对方发送的数据量，可以告知对方目前本身有多少缓冲器容量(Receive Buffer) 还可以接收数据包。当 Window=0 时，代表缓冲器已经额满，所以应该要暂停传输数据。TCP通过滑动窗口的概念来进行流量控制。设想在发送端发送数据的速度很快而接收端接收速度却很慢的情况下，为了保证数据不丢失，显然需要进行流量控制， 协调好通信双方的工作节奏。窗口大小是一个16bit字段，因而窗口大小最大为65535字节。

- 检验和：当数据要由发送端送出前，会进行一个检验的动作，并将该动作的检验值标注在这个字段上； 而接收者收到这个数据包之后，会再次的对数据包进行验证，并且比对原发送的 Checksum 值是否相符，如果相符就接受，若不符就会假设该封包已经损毁，进而要求对方重新发送此封包！在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。

- 紧急指针：这个字段是在 Code 字段内的 URG = 1 时才会产生作用。可以告知紧急数据所在的位置(紧急指针指出在本报文段中的紧急数据的最后一个字节的序号)。

- 选项长度可变：TCP首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。

- 填充字段：这是为了使整个首部长度是4字节的整数倍。

#### 2.TCP三次握手和TCP四次挥手

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200719141951.jpg)

> 注意这个图中的ACK应该为ack(确认号)

##### 三次握手：

- 起初Client处于close状态，Server一直处于listen等待状态。Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
- Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；
- Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。(注意第三次握手的时候Client没有发送序列号过去)

##### 四次挥手：

- 主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在FIN包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。
- 被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
- 被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
- 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

##### 为什么会有TIME-WAIT这个状态呢(第四次挥手)？

这是因为有可能最后一次确认丢失，如果B此时继续向A发送一个我要断开连接的请求等待A发送确认，但此时A已经关闭连接了，那么B永远也关不掉了，所以我们要有TIME-WAIT这个状态。

#### 3.TCP是如何保证其可靠性的？

##### （1）检验和

###### 目的

目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到检验和有差错，则TCP段会被直接丢弃。

TCP在计算检验和时，要加上一个12字节的伪首部。伪首部共有12字节，包含IP首部的一些字段，有如下信息：32位源IP地址、32位目的IP地址、8位保留字节(置0)、8位传输层协议号(TCP是6，UDP是17)、16位TCP报文长度(TCP首部+数据)。伪首部是为了增加TCP校验和的检错能力：通过伪首部的目的IP地址来检查TCP报文是否收错了、通过伪首部的传输层协议号来检查传输层协议是否选对了。

###### 计算过程

需要计算三部分：TCP首部+TCP数据+TCP伪首部。

- 发送端

  - 首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。
  - 把TCP报头中的校验和字段置为0。
  - 其次，用反码相加法（对每16bit进行二进制反码求和）累加所有的16位字（进位也要累加，进位则将高位叠加到低位）。
  - 最后，将上述结果作为TCP的校验和，存在检验和字段中。

- 接受端

  将所有原码相加，高位叠加到低位， 如计算结果的16位中每一位都为1，则正确，否则说明发生错误。

###### 验证示例

 以4bit 为例：

发送端计算：

​    数据：  1000 0100  校验和 0000

​    则反码：0111 1011        1111

​    叠加：  0111+1011+1111 = 0010 0001  高于4bit的， 叠加到低4位   0001 + 0010 = 0011 即为校验和

接收端计算：

​	数据： 1000  0100  检验和 0011

​	反码： 0111  1011        1100

​	叠加： 0111 + 1011 +1100 = 0001 1110 叠加为4bit为1111.  全为1，则正确

##### （2）序列号

tcp每个字节的数据都进行了编号。保证可靠性、数据的按序到达、去除重复数据。（数据传输过程中的确认应答处理、重发控制以及重复可控制等功能都可以通过序列号来实现）

##### （3）确认应答机制

在TCP的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位ACK=1时确认首部的确认字段有效。进行确认时，确认字段值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。

##### （4）超时重传机制

在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？

首先，发送方没有介绍到响应的ACK报文原因可能有两点：

- 数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。
- 接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。

TCP在解决这个问题的时候引入了一个新的机制，叫做超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。

那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？

由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。

> 在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2x500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。

##### （5）连接管理（三次握手、四次挥手）

##### （6）流量控制

接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。

在TCP协议的报头信息当中，有一个16位字段的窗口大小。窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。
![image-20200719152654156](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200719152655.png)

##### （7）拥塞控制

流量控制解决了两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。

为此TCP引入慢启动、拥塞避免、快重传和快恢复这四个算法。

> cwnd：拥塞窗口值
>
> ssthresh：慢启动阈(yu)值
>
> MSS：用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度
>
> RTT（往返时延）：在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。例如拥塞窗口cwnd的大小是4个报文段，那么这时候往返时间RTT就是发送方连续发送4个报文段，并且收到4个报文段的确认，总共经历的时间。

###### 慢启动

一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小；

先初始化cwnd=1,表明可以传一个MSS大小的数据；

每当收到一个ACK，cwnd++，呈线性上升；每过一个RTT，cwnd = cwnd * 2,呈指数上升；因此之后发送方能够发送的报文段数量为：2、4、8 …。注意到慢开始每个轮次都将 cwnd加倍，这样会让 cwnd增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd>=ssthresh时，进入拥塞避免。

> 这里需要说明的一点是，cwnd指数上升的原因是在于cwnd的线性上升。例如：第一次发送cwnd=1，收到一个ACK之后cwnd为2；之后可以发送cwnd=2，收到两个ACK之后cwnd=2+2=4；之后可以发送cwnd=4，收到四个ACK之后cwnd=4+4=8；.......如此反复，导致了cwnd指数上升。

###### 拥塞避免

当拥塞窗口cwnd达到一个阈值时，窗口大小不再呈指数上升，而是每个轮次（RTT）只将 cwnd加 1，让它呈线性上升。

每过一个RTT，cwnd = cwnd + 1（所有的ACK接收到之后加1）；

当发生丢包之后进行数据重传的时候，表示网络已经拥塞，那就要把慢启动阈值(ssthresh)设置为设置为ssthresh = cwnd /2，cwnd(拥塞窗口)设置为1；之后进入慢启动阶段。

###### 快重传

快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认；

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

![image-20200719172029025](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200719172030.png)

 在这种情况下，只是丢失个别报文段，而且发送方收到接收方3个重复确认，证明网络并没有那么糟糕，所以可以执行快恢复。

###### 快恢复

令 ssthresh= cwnd/ 2 ，但是接下来不执行慢启动算法 ，而是设置cwnd = ssthresh，执行拥塞避免算法，使cwnd缓慢增大。

> 注意：
>
>  慢开始和快恢复的快慢指的是 cwnd的设定值，而不是 cwnd的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd设定为 ssthresh。

### 二、UDP

#### 1.首部组成结构

![image-20200719141212881](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200719141214.png)

- 源端口：是一个大于1023的16位数字，由基于UDP应用程序的用户进程随机选择
- 目的端口：要传达的主机程序
- 数据包长度：指明了包括首部在内的UDP报文段长度，该值是UDP报文首部长度（8字节）+UDP携带数据长度的总和。
- 检验和字段：指的是UDP报文首部和UDP所携带的数据的校验和（也包括伪报文头）。伪报文头不包括在真正的UDP报文首部中，但是它可以保证UDP数据被正确的主机收到了。因在检验和中加入了伪头标，故ICMP除了能防止单纯数据差错之外，对IP分组也具有保护作用。

### 三、TCP和UDP的区别

- TCP是面向连接的，它提供可靠的传输服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。而UDP是无连接的，它尽最大努力交付，即不保证可靠交付。
- TCP是面向字节流，UDP面向报文，发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。并且UDP网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用有IP电话和视频会议等）。
- TCP的首部最小为20字节最大为60字节（比UDP多了序列号、确认号、6个状态控制码以及窗口等），而UDP只有8字节（源端口、目的端口、数据包长度和校验值）。
- TCP只能是1对1的，UDP支持1对1,1对多。

> TCP支持的应用协议：Telnet(远程登录)、FTP(文件传输协议)、SMTP(简单邮件传输协议)。TCP用于传输数据量大，可靠性要求高的应用。
>
> UDP支持的应用协议：NFS(网络文件系统)、SNMP(简单网络管理系统)、DNS(主域名称系统)、TFTP(通用文件传输协议)、snmp 简单的网络管理协议、dhcp:动态主机设置协议等。

