---
typora-copy-images-to: upload
---

# 排序

**1.有效的字母异位词**

字母异位词指的是：指字母相同，但排列不同的字符串。

![image-20200620094212739](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200620094227.png)

**第一步我的解法：(排序)**

思路：先将两个字符串转为数组，对两个数组进行排序。之后同时遍历两个数组，每一步相同直到最后就认为是字母异位词，否则为false。

    var isAnagram = function (s, t) {
        let sArr = s.split("");
        let tArr = t.split("");
        sArr.sort();
        tArr.sort();
        let i, j;
        for (i = 0, j = 0; i < sArr.length && j < tArr.length; i++ , j++) {
            if (sArr[i] == tArr[j])
                continue;
            else
                return false;
        }
        if (i == sArr.length && j == tArr.length)
            return true;
        else return false;
    };

优化：我们不一定要逐个数组的元素去比较，我们直接将数组转为string再对比。（省略了很多代码，当然这限定在不需要判断每个字符的类型上）

    var isAnagram = function (s, t) {
        let sArr = s.split("");
        let tArr = t.split("");
        return sArr.sort().toString()==tArr.sort().toString();
    };

时间复杂度：O(nlogn)，假设 n 是 s的长度，排序成本 O(nlogn) 和比较两个字符串的成本 O(n)。排序时间占主导地位，总体时间复杂度为 O(nlogn)。

**另一种解法（map）：**

思路：使用哈希map,为了检查 t 是否是 ss的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为 S 和 T 都只包含 A-Z的字母，所以一个简单的 26 位计数器表就足够了。我们需要两个计数器数表进行比较吗？实际上不是，因为我们可以用一个计数器表计算 ss 字母的频率，用 tt 减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。

    var isAnagram = function (s, t) {
    
      if (s.length!= t.length) {
    
        return false;
    
      }
    
      let arr =new Array(26).fill(0);
    
      for(let i =0;i<s.length;i++){
    
        arr[s.charCodeAt(i)-'a'.charCodeAt()]++;
    
      }
    
       for(let i =0;i<t.length;i++){
    
        arr[t.charCodeAt(i)-'a'.charCodeAt()]--;
    
        if(arr[t.charCodeAt(i)-'a'.charCodeAt()]<0){
    
          return false;
    
        }
    
      }
    
      return true;
    
    };

