# 生命周期详解

Vue 实例有一个完整的生命周期，也就是从开始创建 ->初始化数据 ->编译模版 ->挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

vue是什么？

vue其实是一个类，还需要明确的是每个组件都是vue的一个实例。

```js
function Vue(options) {
  ...	//这是是一些边界情况，判断使用时是不是new Vue()形式，如果不是会报错
  this._init(options)
}

```

> vue的具体运行流程原理可参考下面这篇文章：https://juejin.im/post/5d2dbf5f5188256b432322f3
>
> vue的生命周期图示可参考 官网：[https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90](https://cn.vuejs.org/v2/guide/instance.html#实例生命周期钩子)

### 1.beforeCreate

##### 定义

组件实例被创建之初，组件的属性生效之前（data、methods中的数据还没有初始化）

##### 完成的事情

- initLifecycle(vm)：确认组件的父子关系

  > 首先会找到当前组件第一个非抽象类型的父组件，所以如果当前组件有父级且当前组件不是抽象组件就一直向上查找，直至找到后将找到的父级赋值给实例属性`vm.$parent`，然后将当前实例`push`到找到的父级的`$children`实例属性内，从而建立组件的父子关系。

- initEvents(vm)：将父组件的自定义事件传递给子组件

  > 

- initRender(vm)：提供render函数转为vnode的方法

- beforeCreate：执行组件的beforeCreate钩子函数

##### 常见考点

请问可以在`beforeCreate`钩子内通过`this`访问到`data`中定义的变量么，为什么以及请问这个钩子可以做什么？

> 是不可以访问的，因为在`vue`初始化阶段，这个时候`data`中的变量还没有被挂载到`this`上，这个时候访问值会是`undefined`。`beforeCreate`这个钩子在平时业务开发中用的比较少，而像插件内部的`instanll`方法通过`Vue.use`方法安装时一般会选在`beforeCreate`这个钩子内执行，`vue-router`和`vuex`就是这么干的。

### 2.created

### 3.beforeMount

### 4.mounted

##### 定义

##### 完成的事情

简单回顾一下之前遇到的mountCompoment方法：

```js
export function mountComponent(vm, el) {
  vm.$el = el
  ...
  callHook(vm, 'beforeMount')
  ...
  const updateComponent = function () {
    vm._update(vm._render())
  }
  ...
}
```

我们已经执行完了`vm._render`方法拿到了`VNode`，现在将它作为参数传给`vm._update`方法并执行。`vm._update`这个方法的作用就是就是将`VNode`转为真实的`Dom`，不过它有两个执行的时机：

- 首次渲染

  > 当执行`new Vue`到此时就是首次渲染了，会将传入的`VNode`对象映射为真实的`Dom`。
  >
  > 先来看看vm._update方法的定义：
  >
  > ```js
  > Vue.prototype._update = function(vnode) {
  >   ... 首次渲染
  >   vm.$el = vm.__patch__(vm.$el, vnode)  // 覆盖原来的vm.$el
  >   ...
  > }
  > ```
  >
  > 这里的`vm.$el`是之前在`mountComponent`方法内就挂载的，一个真实`Dom`元素。首次渲染会传入`vm.$el`以及得到的`VNode`，所以看下`vm.__patch__`定义：
  >
  > ```js
  > Vue.prototype.__patch__ = createPatchFunction({ nodeOps, modules }) 
  > ```
  >
  > 生成dom：无论`VNode`是什么类型的节点，只有三种类型的节点会被创建并插入到的`Dom`中：元素节点、注释节点、和文本节点。
  >
  > ```js
  > export function createPatchFunction(backend) {
  >   ...
  >   const { modules, nodeOps } = backend  // 解构出传入的集合
  >   
  >   return function (oldVnode, vnode) {  // 接收新旧vnode
  >     ...
  >     
  >     const isRealElement = isDef(oldVnode.nodeType) // 是否是真实Dom
  >     if(isRealElement) {  // $el是真实Dom
  >       oldVnode = emptyNodeAt(oldVnode)  // 转为VNode格式覆盖自己
  >     }
  >     ...
  >   }
  > }
  > ```
  >
  > 首次渲染时没有`oldVnode`，`oldVnode`就是`$el`，一个真实的`dom`，经过`emptyNodeAt(oldVnode)`方法包装(将$el属性转为了VNode格式)：
  >
  > ```js
  > function emptyNodeAt(elm) {
  >   return new VNode(
  >     nodeOps.tagName(elm).toLowerCase(), // 对应tag属性
  >     {},  // 对应data
  >     [],   // 对应children
  >     undefined,  //对应text
  >     elm  // 真实dom赋值给了elm属性
  >   )
  > }
  > 
  > 包装后的：
  > {
  >   tag: 'div',
  >   elm: '<div id="app"></div>' // 真实dom
  > }
  > 
  > -------------------------------------------------------
  > 
  > nodeOps：
  > export function tagName (node) {  // 返回节点的标签名
  >   return node.tagName  
  > }
  > ```
  >
  > 再将传入的`$el`属性转为了`VNode`格式之后，我们继续：
  >
  > ```js
  > export function createPatchFunction(backend) { 
  >   ...
  >   
  >   return function (oldVnode, vnode) {  // 接收新旧vnode
  >   
  >     const insertedVnodeQueue = []
  >     ...
  >     const oldElm = oldVnode.elm  //包装后的真实Dom <div id='app'></div>
  >     const parentElm = nodeOps.parentNode(oldElm)  // 首次父节点为<body></body>
  >   	
  >     createElm(  // 创建真实Dom
  >       vnode, // 第二个参数
  >       insertedVnodeQueue,  // 空数组
  >       parentElm,  // <body></body>
  >       nodeOps.nextSibling(oldElm)  // 下一个节点
  >     )
  >     
  >     return vnode.elm // 返回真实Dom覆盖vm.$el
  >   }
  > }
  >                                               
  > ```
  >
  > `createElm`方法开始生成真实的`Dom`，`VNode`生成真实的`Dom`的方式还是分为元素节点和组件两种方式。
  >
  > ```js
  > {  // 元素节点VNode
  >   tag: 'div',		//遍历完子节点插入到body内
  >   children: [{		//遍历每一项，挨个插入到div内
  >       tag: 'h1',	//创建h1节点
  >       children: [	//遍历每一项=>添加到h1节点
  >         {text: 'title h1'}
  >       ]
  >     }, {
  >       tag: 'h2',	//创建h2节点
  >       children: [	//遍历每一项=>添加到h2节点
  >         {text: 'title h2'}
  >       ]
  >     }, {
  >       tag: 'h3',	//创建h3节点
  >       children: [	//遍历每一项=>添加到h3节点
  >         {text: 'title h3'}
  >       ]
  >     }
  >   ]
  > }
  > 
  > ```

  简单来说就是由里向外的挨个创建出真实的`Dom`，然后插入到它的父节点内，最后将创建好的`Dom`插入到`body`内，完成创建的过程，元素节点的创建还是比较简单的。

  组件创建这里暂时忽略。

- 更新页面

  > ...

我们再将本章最初的`mountComponent`之后的逻辑补充完整：

```js
export function mountComponent(vm, el) {
  ...
  const updateComponent = () => {
    vm._update(vm._render())
  }
  
  new Watcher(vm, updateComponent, noop, {
    before() {
      if(vm._isMounted) {
        callHook(vm, 'beforeUpdate')
      }
    }   
  }, true)
  
  ...
  callHook(vm, 'mounted')
  
  return vm
}
```

##### 常见考点

父子两个组件同时定义了`beforeCreate`、`created`、`beforeMounte`、`mounted`四个钩子，它们的执行顺序是怎么样的？

> 首先会执行父组件的初始化过程，所以会依次执行`beforeCreate`、`created`、在执行挂载前又会执行`beforeMount`钩子，不过在生成真实`dom`的`__patch__`过程中遇到嵌套子组件后又会转为去执行子组件的初始化钩子`beforeCreate`、`created`，子组件在挂载前会执行`beforeMounte`，再完成子组件的`Dom`创建后执行`mounted`。这个父组件的`__patch__`过程才算完成，最后执行父组件的`mounted`钩子，这就是它们的执行顺序。执行顺序如下：
>
> ```js
> parent beforeCreate
> parent created
> parent beforeMounte
>     child beforeCreate
>     child created
>     child beforeMounte
>     child mounted
> parent mounted
> ```

### 5.beforeUpdate

##### 定义

组件数据更新之前调用，发生在虚拟DOM 打补丁前

### 6.update

##### 定义

组件数据更新之后

![img](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200718124123.jpg)

### 7.activited

##### 定义

keep-alive 专属，组件被激活时调用 

### 8.deactivated

##### 定义

keep-alive 专属，组件被销毁时调用

### 9.beforeDestory

##### 定义

组件销毁前调用 （实例身上所有的data和所有的         methods,以及过滤器、指令等都处于可用状态，还 没有真正执行销毁的过程）

### 10.destoryed

##### 定义

组件销毁后调用（自建已经被完全销毁了，此时组件中       的所有数据都不可以用）

