### 一、闭包有关

1.实现每调用一次函数变量就会自增1

```js
function generateId() {
    let n = 0;
    return function(){
        console.log(n++);
    }
}

let generator = generateId();

var a = generator(); // 输出0
var b = generator(); // 输出1
generator(); // 输出2
```



### 二、this指向相关

1.写出下面的输出答案

```js
//先看一个箭头函数的例子
var handler = {
  id: '123456',

  init: function() {
    document.addEventListener('click',
      event => this.doSomething(event.type), false);
  },

  doSomething: function(type) {
    console.log('Handling ' + type  + ' for ' + this.id);
  }
};
//上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。
```

```js
//html
<div style="width: 100px;height: 100px;border: 1px solid red;"></div>
//js
window.data = 5;
var foo = {
    data: 6,
    click: () => {
        console.log(this.data);
    }
};
let div = document.getElementsByTagName("div")[0];
//如果click为function(){},那么答案为underfined。因为此时的this绑定的是div元素，而不是foo对象。如果click为()=>{},那么箭头函数中的this会绑定在了window上，所以输出结果是5
div.addEventListener('click', foo.click); //5

var bar = foo.click;
bar();//5
```

```js
function foo() {
  return () => {
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});

var t1 = f.call({id: 2})()(); // id: 1
var t2 = f().call({id: 3})(); // id: 1
var t3 = f()().call({id: 4}); // id: 1
//上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。

//就算把代码改成：
function foo() {
  return () => {
    console.log('id0:', this.id);
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});
var t1 = f.call({id: 2}); //id0:1;
//不管怎么绑定，箭头函数里面的this都是最外层foo函数的this
```

### 三、排序相关

1.合并两个有序数组

```js
let a = [2];
let b = [1,2,3,4,667];
//第一种方法：借助新数组
function merge(a, b) {
    let result = [];
    let i=0, j = 0;
    if(!a.length) return b;
    if(!b.length) return a;
    while (i < a.length && j < b.length) {
        if (a[i] < b[j]) {
            result.push(a[i]);
            i++;
        } else {
            result.push(b[j]);
            j++;
        }
    }
    while (i < a.length) {
        result.push(a[i]);
        i++;
    }
    while (j < b.length) {
        result.push(b[j]);
        j++;
    }
    return result;
}
console.log(merge(a, b));

```

```js
//第二种，在原有数组进行
function merge(a, b) {
    let i = 0,
        j = 0;
    if (!a.length) return b;
    if (!b.length) return a;
    while (j < b.length) {
        if (a[i] < b[j]) {
            i++;
        } else {
            //在i的位置上删除0项，并添加b[j];
            a.splice(i, 0, b[j]);
            i++;
            j++;
        }
    }

    return a;
}
console.log(merge(a, b));
```

2.js判断对多个版本号进行降序怎么做？

```js
//第一种：使用sort方法
let arr = ['0.1.1', '2.3.3', '0.3002.1', '4.2', '4.3.5', '4.3.4.5'];
arr.sort((a, b) => a > b ? -1 : 1);
console.log(arr);
//我们在使用sort函数时，默认是直接return a-b，得到的是升序序列。
//a-b>0 =>返回正数，a往后排
//a-b<0 =>返回负数，a往前排
//所以上面我们要实现降序就要对a>b进行判断，a>b时让它返回负数，a往前排。
```

```js
//第二种：使用选择排序，复杂度有点高
let arr = ['0.1.1','0.1.1.0', '2.3.3', '0.3002.1', '4.2', '4.3.5', '4.3.4.5'];
const versionSort = version => {
    const temp = version.map(v => v.split('.'));
    for (let i = 0; i < temp.length; i++) {
        let minIndex = i;
        for (let j = i; j < temp.length; j++) {
            for (let k = 0; k < temp[j].length; k++) {
                const current = +temp[j][k],
                      min = +temp[minIndex][k];
                if (current < min) {
                    minIndex = j;
                }
                // 只要不等，就立刻结束最内层遍历！
                if (current !== min) {
                    break
                }
            }
        }
        [temp[i], temp[minIndex]] = [temp[minIndex], temp[i]];
    }
    return temp.map(v => v.join('.'))
};
console.log(versionSort(arr));
```

### 四、深克隆

```js
function deepClone(object){
    if(typeof object === "object"){
        let cloneObject = Array.isArray(object)?[]:{};
        for(let key in object){
            cloneObject[key] = deepClone(object[key]);
        }
        return cloneObject;
    }
    //基础数据类型+function类型
    else{
        return object;
    }
}
```

### 五、数组有关

1.判断是否是数组

```js
//三种方法
let arr = [2,23];
console.log(Array.isArray(arr));
console.log(arr instanceof Array);
console.log(Object.prototype.toString.call(arr) === '[object Array]');

//还有一种也是可以的。想想每一个实例化出来的arr都在原型上有个constructor属性指向生成它的对象。但是要注意constructor是可以被改写的。
console.log(arr.constructor == Array)
```

2.数组去重

```js
//第一种：set方法 ({}去重失败)
let arr = [1,1,'q','q',{},{},true,'true',NaN,NaN,"NaN",undefined,undefined,null,null];
arr = Array.from(new Set(arr));
//console.log([...new Set(arr)])
console.log(arr);


//第二种：双重for循环+splice ({},NaN去重失败)
for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
        if (arr[i] === arr[j]) {
            arr.splice(j, 1);
            j--;
        }
    }
}
console.log(arr);

//第三种：使用indexOf+新数组 ({},NaN去重失败)
let newArr=[];
for (let i = 0; i < arr.length; i++) {
    if(newArr.indexOf(arr[i]) == -1) {
        newArr.push(arr[i]);
    }   
}
console.log(newArr);

//第四种：使用filter ({}未去重，NaN全部删除了)
 arr = arr.filter((item,index,arr)=>{
     //当前数组中，若该item在原始数组中的第一个索引==当前索引，则返回当前元素
     return arr.indexOf(item,0) === index;
 })
console.log(arr);
```

### 六、防抖和节流

1.防抖

2.节流

### 七、原型链相关

前置知识点：

![image-20200725211926130](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200725211928.png)

```js
function Person(name){
    this.name = name;
}
let p = new Person('king');

console.log(p.__proto__) //Person Prototype

console.log(p.__proto__.__proto__) //Object.prototype;因为Person Prototype(是一个对象)的__proto__那就是oject.__proto__ = Object.prototype；

console.log(p.__proto__.__proto__.__proto__) //null;因为Object.prototype.__proto__ = null;

console.log(p.constructor) //Person;会去原型上找constructor属性

console.log(p.prototype) //undefined;因为p是实例对象，无protoytype属性

console.log(Person.constructor) //Function; Person是Function的一个实例，Person通过__proto__属性访问到Function Prototype,Function Prototype中的constructor = Function(一个空函数)；

console.log(Person.prototype) //打印出Person.prototype这个对象的方法和属性

console.log(Person.prototype.constructor) //Person

console.log(Person.prototype.__proto__) //Object.prototype;

console.log(Person.__proto__) //Function.prototype
```

1.写出下面的输出答案：

```js
var F = function() {};

Object.prototype.a = function() {
    console.log('a');
};
Function.prototype.b = function() {
    console.log('b');
} ;
var f = new F();
f.a(); //a
f.b(); //TypeError: f.b() is not a function
F.a(); //a
F.b(); //b

//根据上面的例子去做这道题就懂了
```

### 八、作用域相关（var、let）

1.写出下面的输出答案：

```js
for (let i = 0; i < 3; i++) {
	setTimeout(() => console.log(i), 1);
}
//0,1,2

for (var j = 0; j < 3; j++) {
	setTimeout(() => console.log(j), 1);
}
//3,3,3
```

### 九、变量提升有关

1.写出下面的输出答案

```js
function Foo() {
    Foo.a = function() {
    console.log(1)
}
this.a = function() {
    console.log(2)
}
}
Foo.prototype.a = function() {
    console.log(3)
}
Foo.a = function() {
    console.log(4)
}

Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

### 十、事件循环有关

1.写出下面的输出答案

```js
async function async1() {
	console.log('async1 start');
}

await async2();
	console.log('async1 end');
}

async function async2() {
	console.log('async2');
}

console.log('script start');

setTimeout(function() {
	console.log('setTimeout');
}, 0);

async1();

new Promise(function(resolve) {
	console.log('promise1');
	resolve();
}).then(function() {
	console.log('promise2');
});

console.log('script end');
```



