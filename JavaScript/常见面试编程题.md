### 一、闭包有关

1.实现每调用一次函数变量就会自增1

```js
function generateId() {
    let n = 0;
    return function(){
        console.log(n++);
    }
}

let generator = generateId();

var a = generator(); // 输出0
var b = generator(); // 输出1
generator(); // 输出2
```



### 二、this指向相关

1.写出下面的输出答案

```js
//先看一个箭头函数的例子
var handler = {
  id: '123456',

  init: function() {
    document.addEventListener('click',
      event => this.doSomething(event.type), false);
  },

  doSomething: function(type) {
    console.log('Handling ' + type  + ' for ' + this.id);
  }
};
//上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。
```

```js
//html
<div style="width: 100px;height: 100px;border: 1px solid red;"></div>
//js
window.data = 5;
var foo = {
    data: 6,
    click: () => {
        console.log(this.data);
    }
};
let div = document.getElementsByTagName("div")[0];
//如果click为function(){},那么答案为underfined。因为此时的this绑定的是div元素，而不是foo对象。如果click为()=>{},那么箭头函数中的this会绑定在了window上，所以输出结果是5
div.addEventListener('click', foo.click); //5

var bar = foo.click;
bar();//5
```

```js
function foo() {
  return () => {
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});

var t1 = f.call({id: 2})()(); // id: 1
var t2 = f().call({id: 3})(); // id: 1
var t3 = f()().call({id: 4}); // id: 1
//上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。

//就算把代码改成：
function foo() {
  return () => {
    console.log('id0:', this.id);
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});
var t1 = f.call({id: 2}); //id0:1;
//不管怎么绑定，箭头函数里面的this都是最外层foo函数的this
```

### 三、排序相关

1.合并两个有序数组

```js
let a = [2];
let b = [1,2,3,4,667];
//第一种方法：借助新数组
function merge(a, b) {
    let result = [];
    let i=0, j = 0;
    if(!a.length) return b;
    if(!b.length) return a;
    while (i < a.length && j < b.length) {
        if (a[i] < b[j]) {
            result.push(a[i]);
            i++;
        } else {
            result.push(b[j]);
            j++;
        }
    }
    while (i < a.length) {
        result.push(a[i]);
        i++;
    }
    while (j < b.length) {
        result.push(b[j]);
        j++;
    }
    return result;
}
console.log(merge(a, b));

```

```js
//第二种，在原有数组进行
function merge(a, b) {
    let i = 0,
        j = 0;
    if (!a.length) return b;
    if (!b.length) return a;
    while (j < b.length) {
        if (a[i] < b[j]) {
            i++;
        } else {
            //在i的位置上删除0项，并添加b[j];
            a.splice(i, 0, b[j]);
            i++;
            j++;
        }
    }

    return a;
}
console.log(merge(a, b));
```

2.js判断对多个版本号进行降序怎么做？

```js
//第一种：使用sort方法
let arr = ['0.1.1', '2.3.3', '0.3002.1', '4.2', '4.3.5', '4.3.4.5'];
arr.sort((a, b) => a > b ? -1 : 1);
console.log(arr);
//我们在使用sort函数时，默认是直接return a-b，得到的是升序序列。
//a-b>0 =>返回正数，a往后排
//a-b<0 =>返回负数，a往前排
//所以上面我们要实现降序就要对a>b进行判断，a>b时让它返回负数，a往前排。
```

```js
//第二种：使用选择排序，复杂度有点高
let arr = ['0.1.1','0.1.1.0', '2.3.3', '0.3002.1', '4.2', '4.3.5', '4.3.4.5'];
const versionSort = version => {
    const temp = version.map(v => v.split('.'));
    for (let i = 0; i < temp.length; i++) {
        let minIndex = i;
        for (let j = i; j < temp.length; j++) {
            for (let k = 0; k < temp[j].length; k++) {
                const current = +temp[j][k],
                      min = +temp[minIndex][k];
                if (current < min) {
                    minIndex = j;
                }
                // 只要不等，就立刻结束最内层遍历！
                if (current !== min) {
                    break
                }
            }
        }
        [temp[i], temp[minIndex]] = [temp[minIndex], temp[i]];
    }
    return temp.map(v => v.join('.'))
};
console.log(versionSort(arr));
```

### 四、深克隆

```js
function deepClone(object){
    if(typeof object === "object"){
        let cloneObject = Array.isArray(object)?[]:{};
        for(let key in object){
            cloneObject[key] = deepClone(object[key]);
        }
        return cloneObject;
    }
    //基础数据类型+function类型
    else{
        return object;
    }
}
```

### 五、数组有关

1.判断是否是数组

```js
//三种方法
let arr = [2,23];
console.log(Array.isArray(arr));
console.log(arr instanceof Array);
console.log(Object.prototype.toString.call(arr) === '[object Array]');

//还有一种也是可以的。想想每一个实例化出来的arr都在原型上有个constructor属性指向生成它的对象。但是要注意constructor是可以被改写的。
console.log(arr.constructor == Array)
```

2.数组去重

```js
//第一种：set方法 ({}去重失败)
let arr = [1,1,'q','q',{},{},true,'true',NaN,NaN,"NaN",undefined,undefined,null,null];
arr = Array.from(new Set(arr));
//console.log([...new Set(arr)])
console.log(arr);


//第二种：双重for循环+splice ({},NaN去重失败)
for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
        if (arr[i] === arr[j]) {
            arr.splice(j, 1);
            j--;
        }
    }
}
console.log(arr);

//第三种：使用indexOf+新数组 ({},NaN去重失败)
let newArr=[];
for (let i = 0; i < arr.length; i++) {
    if(newArr.indexOf(arr[i]) == -1) {
        newArr.push(arr[i]);
    }   
}
console.log(newArr);

//第四种：使用filter ({}未去重，NaN全部删除了)
 arr = arr.filter((item,index,arr)=>{
     //当前数组中，若该item在原始数组中的第一个索引==当前索引，则返回当前元素
     return arr.indexOf(item,0) === index;
 })
console.log(arr);
```

### 六、防抖和节流

1.防抖

2.节流

### 七、原型链相关

前置知识点：

![image-20200725211926130](https://raw.githubusercontent.com/ahaMOMO/autumn-stroke/master/img/20200725211928.png)

```js
function Person(name){
    this.name = name;
}
let p = new Person('king');

console.log(p.__proto__) //Person Prototype

console.log(p.__proto__.__proto__) //Object.prototype;因为Person Prototype(是一个对象)的__proto__那就是oject.__proto__ = Object.prototype；

console.log(p.__proto__.__proto__.__proto__) //null;因为Object.prototype.__proto__ = null;

console.log(p.constructor) //Person;会去原型上找constructor属性

console.log(p.prototype) //undefined;因为p是实例对象，无protoytype属性

console.log(Person.constructor) //Function; Person是Function的一个实例，Person通过__proto__属性访问到Function Prototype,Function Prototype中的constructor = Function(一个空函数)；

console.log(Person.prototype) //打印出Person.prototype这个对象的方法和属性

console.log(Person.prototype.constructor) //Person

console.log(Person.prototype.__proto__) //Object.prototype;

console.log(Person.__proto__) //Function.prototype
```

1.写出下面的输出答案：

```js
var F = function() {};

Object.prototype.a = function() {
    console.log('a');
};
Function.prototype.b = function() {
    console.log('b');
} ;
var f = new F();
f.a(); //a
f.b(); //TypeError: f.b() is not a function
F.a(); //a
F.b(); //b

//根据上面的例子去做这道题就懂了
```

### 八、作用域相关（var、let）

1.写出下面的输出答案：

```js
for (let i = 0; i < 3; i++) {
	setTimeout(() => console.log(i), 1);
}
//0,1,2

for (var j = 0; j < 3; j++) {
	setTimeout(() => console.log(j), 1);
}
//3,3,3
```

### 九、变量提升有关

![image-20200726003323011](%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98/image-20200726003323011.png)

1.写出下面的输出答案

```js
function Foo() {
    Foo.a = function() {
    	console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
Foo.prototype.a = function() {
    console.log(3)
}
Foo.a = function() {
    console.log(4)
}

Foo.a();	//4
let obj = new Foo();
obj.a();	//2
Foo.a();	//1
```

```js
 function Foo() {
     getName = function () {
         console.log(1);
     };
     return this;
 };
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
};

Foo.getName(); //2；
getName(); //4；
Foo().getName(); //1
getName();	//1
new Foo.getName();	//2
new Foo().getName();	//3
new new Foo().getName(); //3
```

分析：

首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。

- Foo.getName(); //2； 

  Foo.getName 自然是访问Foo函数上存储的静态属性，自然是2。

- getName();//4；

  这里考的是变量提升与函数声明提升。这样就存在一个问题了，变量声明会提升，函数声明也会提升，谁提升的更高呢？在你不知道的JavaScript中明确指出，函数声明会被优先提升，也就是说都是提升，但是函数比变量提升更高，所以题目中的两个函数顺序可以改写成：

  ```js
  function getName() {
      console.log(5);
  };
  
  var getName;
  
  getName = function () {
      console.log(4);
  };
  
  ```

  所以最后答案就输出了为4。

- Foo().getName(); //1;  

  其实可以看出来，我们在执行Foo()函数的时候getName这个变量提升到外部的全局作用域中了，因为在js中，如果对于一个变量没用用var 或者 let等声明的话，他就默认是全局属性,就是window对象的一个属性。所以在这里我们的全局的getName又被改了。

  因为我们Foo()执行的时候返回了this而这里的this就是window对象 。所以window.getName()就为1了。

- getName()； //1；

  这里输出1已经毫无悬念，上一分析中，getName的值在Foo执行时被修改了，所以再调用getName一样等同于window.getName()，同样是输出1。

- new Foo.getName(); //2

  **优先级：new Foo() > Foo() > new Foo**

  先运算Foo.getName() 结果为“2”，再new一个Foo实例对象,因此这里new的过程就相当于单纯把Foo.getName执行了一遍输出2。

- new Foo().getName();	//3

  这里考了new基本概念，首先这个调用分为两步，第一步new Foo()得到一个实例，第二步调用实例的getName方法。

  在执行new Foo()时，先以Foo原型创建了一个对象，由于Foo.prototype上事先设置了一个getName方法（输出3的那个），所以这个对象可通过原型访问到这个方法。其次由于Foo内部也没提供什么构造器属性，所以最终返回的实例会通过__proto__去原型上找getName（）执行，所以输出为3。

- new new Foo().getName()；//3

  相当于new(new Foo().getName()) 先执行new Foo().getName()，由上面知道输出3，最后创建Foo.prototype.getName()的实例返回。结果为3。

### 十、事件循环有关

1.写出下面的输出答案

```js
async function async1() {
	console.log('async1 start');
}

await async2();
	console.log('async1 end');
}

async function async2() {
	console.log('async2');
}

console.log('script start');

setTimeout(function() {
	console.log('setTimeout');
}, 0);

async1();

new Promise(function(resolve) {
	console.log('promise1');
	resolve();
}).then(function() {
	console.log('promise2');
});

console.log('script end');
```



